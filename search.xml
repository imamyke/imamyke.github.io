<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>如何利用Node.js及Express框架打造伺服器及靜態網頁</title>
    <url>/2023/01/11/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Node-js%E5%8F%8AExpress%E6%A1%86%E6%9E%B6%E6%89%93%E9%80%A0%E4%BC%BA%E6%9C%8D%E5%99%A8%E5%8F%8A%E9%9D%9C%E6%85%8B%E7%B6%B2%E9%A0%81/</url>
    <content><![CDATA[<h1 id="AC-學期-2-3-利用-Node-js-及-Express-框架打造伺服器及靜態網頁-一"><a href="#AC-學期-2-3-利用-Node-js-及-Express-框架打造伺服器及靜態網頁-一" class="headerlink" title="[AC 學期 2-3]利用 Node.js 及 Express 框架打造伺服器及靜態網頁(一)"></a>[AC 學期 2-3]利用 Node.js 及 Express 框架打造伺服器及靜態網頁(一)</h1><h2 id="star-學習建議"><a href="#star-學習建議" class="headerlink" title=":star: 學習建議"></a>:star: 學習建議</h2><p>在學習 Express 框架及打造伺服器之前，我們必須要<strong>先了解網際網路傳輸原理</strong>，這樣在學習框架上，就會<strong>知道為何要設定這些東西</strong>，學習上也會更如魚得水唷!</p>
<p>但這裡會偏向實作也會簡述原理，若要更深入可以在網路上或透過最下方參考資料查詢更多。</p>
<h2 id="computer-用戶端與伺服器端的-HTTP-傳輸協定"><a href="#computer-用戶端與伺服器端的-HTTP-傳輸協定" class="headerlink" title=":computer: 用戶端與伺服器端的 HTTP 傳輸協定"></a>:computer: 用戶端與伺服器端的 HTTP 傳輸協定</h2><h3 id="one-什麼是-HTTP"><a href="#one-什麼是-HTTP" class="headerlink" title=":one: 什麼是 HTTP ?"></a>:one: 什麼是 HTTP ?</h3><p>我們人跟人之間溝通會跟對方用聽得懂的語言做溝通，同樣地電腦設備也是，而電腦設備間溝通的語言就叫 HTTP。</p>
<p>:books: <strong>HTTP 簡介</strong></p>
<ul>
<li>也稱作<strong>超文本傳輸協定</strong>，英文為<strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol</li>
<li>電腦設備間互相索取文件的溝通語言</li>
</ul>
<blockquote>
<p>簡單來說，用戶端(client)跟伺服器端(server)請求文件，或是伺服器端(server)給予用戶端(client)相應的回應時，都需要透過 HTTP 來溝通。</p>
</blockquote>
<h3 id="two-HTTP-的組成結構是什麼"><a href="#two-HTTP-的組成結構是什麼" class="headerlink" title=":two: HTTP 的組成結構是什麼?"></a>:two: HTTP 的組成結構是什麼?</h3><p>在 HTTP 組成結構學習上要專注於英文的命名，會跟接下來的應用有關唷!</p>
<table>
<thead>
<tr>
<th align="center">HTTP Request</th>
<th align="center">HTTP Response</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Request Line(method + URL)</td>
<td align="center">Response Status</td>
</tr>
<tr>
<td align="center">Request Headers</td>
<td align="center">Response Headers</td>
</tr>
<tr>
<td align="center">Request Body</td>
<td align="center">Response Body</td>
</tr>
</tbody></table>
<p>:pushpin: <strong>HTTP Request</strong></p>
<ul>
<li><p><strong>Request <code>Line</code>:</strong> 包含<code>Request Method</code>和<code>Request URL</code>，以及 HTTP 版本。</p>
<ul>
<li><p><strong>Request Method:</strong> 常見如下表。</p>
<table>
<thead>
<tr>
<th align="center">Method</th>
<th align="center">說明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>GET</strong></td>
<td align="center">讀取資料</td>
</tr>
<tr>
<td align="center"><strong>POST</strong></td>
<td align="center">新增資料</td>
</tr>
<tr>
<td align="center"><strong>PUT</strong></td>
<td align="center">修改資料(如果沒有該筆資料存在，就會新增資料)</td>
</tr>
<tr>
<td align="center"><strong>PATCH</strong></td>
<td align="center">修改資料</td>
</tr>
<tr>
<td align="center"><strong>DELETE</strong></td>
<td align="center">刪除資料</td>
</tr>
</tbody></table>
</li>
<li><p><strong>Request URL:</strong> 用戶端請求資源的伺服器網址。</p>
</li>
</ul>
</li>
<li><p><strong>Request <code>Headers</code>:</strong> 主要是客戶端向伺服器端請求的訊息，且每一行欄位內容由 <code>name: value</code> 成對組成，最常見的 Header 如下:</p>
<ul>
<li><strong>Host:</strong> 請求的伺服器主機名稱。</li>
<li><strong>Content-Type:</strong> 請求內容格式類型，例如純文字檔(text&#x2F;plain)、HTML 格式(text&#x2F;html)等等，有興趣的可以網下方參考資料來源查詢。</li>
</ul>
</li>
<li><p><strong>Request <code>Body</code>:</strong> 通常是在用戶端以 POST 方式請求時，會把客戶的資訊放在 Request body 裡，提交給指定的 URL。</p>
</li>
</ul>
<img src="https://images.zapier.com/storage/photos/4717d012f26dc6a4928e0d025102af7f.png?format=jpg" width="50%">

<p>:pushpin: <strong>HTTP Response</strong></p>
<ul>
<li><strong>Response <code>Status</code>:</strong> 包含 HTTP 版本、<a href="https://developer.mozilla.org/zh-TW/docs/Web/HTTP/Status">HTTP 狀態碼</a>以及狀態碼描述，狀態碼常見例如 <strong>2XX</strong> 表示伺服器<strong>成功回應</strong>，<strong>4XX</strong>表示用戶端<strong>錯誤回應</strong>。</li>
<li><strong>Response <code>Headers</code>:</strong> 主要是伺服器端向客戶端回應的訊息，如 Content-Type 定義回應客戶端的內容格式類型。</li>
<li><strong>Response <code>Body</code>:</strong> 伺服器端回應給客戶的內容。</li>
</ul>
<img src="https://images.zapier.com/storage/photos/df8b6d09ab35aac47c1fb7b020a42d61.png?format=jpg" width="50%">

<blockquote>
<p>:memo: <strong>總結:</strong><br><br>HTTP Request 由四元素組成: <strong>URL、Method、Headers、Body</strong><br><br>HTTP Respond 由三元素組成: <strong>Status code、Headers、Body</strong></p>
</blockquote>
<h3 id="three-URL-的結構長怎樣"><a href="#three-URL-的結構長怎樣" class="headerlink" title=":three: URL 的結構長怎樣?"></a>:three: URL 的結構長怎樣?</h3><p><strong><font color=#0000FF>http:&#x2F;&#x2F;</font><font color=#FF6600><a href="http://www.imamyke.com/">www.imamyke.com</a></font>:3000<font color=#008000>&#x2F;categories</font><font color=#800080>&#x2F;?keyword&#x3D;frontend&amp;sort&#x3D;asc</font></strong></p>
<table>
<thead>
<tr>
<th align="center">URL 結構</th>
<th align="left">說明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong><font color=#0000FF>Protocol</font></strong></td>
<td align="left">傳輸協定，不一定是 http 或 https，也有可能是 ssh、ftp、mailto、file</td>
</tr>
<tr>
<td align="center"><strong><font color=#FF6600>Host</font></strong></td>
<td align="left">主機名稱，也就是網域名稱</td>
</tr>
<tr>
<td align="center"><strong>port</strong></td>
<td align="left">通訊埠，通常會隱藏起來</td>
</tr>
<tr>
<td align="center"><strong><font color=#008000>Path</font></strong></td>
<td align="left">檔案路徑</td>
</tr>
<tr>
<td align="center"><strong><font color=#800080>Parameter</font></strong></td>
<td align="left">使用 <strong><code>?</code></strong> 來表示參數的開頭，並用 <strong><code>&amp;</code></strong> 分隔不同的項目， <code>?</code> 之後的字串稱為 <strong>query string</strong>，<br>這個名詞先筆記一下，後面會學習到怎麼使用!<br>在這裡 <code>keyword</code> 和 <code>sort</code> 表示參數，<code>frontend</code> 和 <code>asc</code> 表示參數的值</td>
</tr>
</tbody></table>
<h2 id="pencil2-一起實作吧-用-Node-js-架設伺服器"><a href="#pencil2-一起實作吧-用-Node-js-架設伺服器" class="headerlink" title=":pencil2: 一起實作吧!用 Node.js 架設伺服器"></a>:pencil2: 一起實作吧!用 Node.js 架設伺服器</h2><p>現在，有了以上的知識就開始將文字轉化為程式碼打造自己的伺服器吧!</p>
<p>順道一提，實際做完之後可以對照著 HTTP 結構去思考為何會這樣建立伺服器唷!</p>
<h3 id="one-定義和伺服器有關的變數"><a href="#one-定義和伺服器有關的變數" class="headerlink" title=":one: 定義和伺服器有關的變數"></a>:one: <strong>定義和伺服器有關的變數</strong></h3><p>:triangular_flag_on_post: <strong>Step1. 載入 Node.js 的 HTTP 模組</strong></p>
<p>首先，當然是要讓我們的伺服器會跟其他電腦設備「說話」，<br>那個溝通語言就是 HTTP !</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>載入之後我們把 HTTP 模組存成 <code>http</code> 這個變數，之後就可以利用這個變數來使用 HTTP 模組的方法。</p>
<p>:triangular_flag_on_post: <strong>Step2. 設定伺服器的相關變數</strong></p>
<p>再來，我們要定義伺服器的主機位置，這樣伺服器之間才會知道資料要傳送到哪。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hostname = <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span>;</span><br></pre></td></tr></table></figure>

<h3 id="two-設定伺服器處理請求和回應的動作"><a href="#two-設定伺服器處理請求和回應的動作" class="headerlink" title=":two: 設定伺服器處理請求和回應的動作"></a>:two: <strong>設定伺服器處理請求和回應的動作</strong></h3><p>:triangular_flag_on_post: <strong>Step1. 使用 HTTP 模組方法</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 請求和回應的動作都會在這邊</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>:bulb: <strong>重點說明:</strong></p>
<ul>
<li><p><strong>使用 HTTP 模組方法: createServer</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">http.<span class="property">createServer</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>變數命名</strong></p>
<table>
<thead>
<tr>
<th align="center">請求(Request)</th>
<th align="center">回應(Response)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">req</td>
<td align="center">res</td>
</tr>
</tbody></table>
</li>
</ul>
<p>:triangular_flag_on_post: <strong>Step2. 設定回應的 HTTP 狀態碼 (status code) 和內容格式類型 (Content-Type)</strong></p>
<p>還記得 Response headers 會設定內容格式嗎? 有沒有覺得函式的命名非常語意化 :innocent:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="property">statusCode</span> = <span class="number">200</span>; <span class="comment">// 新增這裡</span></span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/plain&quot;</span>); <span class="comment">// 新增這裡</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>:bulb: <strong>重點說明:</strong></p>
<ul>
<li><p><strong>使用 HTTP 模組方法: setHeader</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&quot;Header欄位名&quot;</span>, <span class="string">&quot;Header欄位值&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>狀態碼: statusCode</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.<span class="property">statusCode</span> = 回應狀態碼;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>:triangular_flag_on_post: <strong>Step3. 伺服器端回應給客戶的內容</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="property">statusCode</span> = <span class="number">200</span>;</span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">  res.<span class="title function_">end</span>(<span class="string">`This is my first server`</span>); <span class="comment">// 新增這裡</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>:bulb: <strong>重點說明:</strong></p>
<ul>
<li><p><strong>使用 HTTP 模組方法: end</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.<span class="title function_">end</span>(<span class="string">&quot;依照Content-Type的格式回應內容&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>如何回傳 HTML?</strong></p>
<p>這邊我們回應的 Content-Type 是使用純文字 text&#x2F;plain 表示。<br><br>如果要回傳成 HTML，我們可以這樣改寫 :arrow_down:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">res.<span class="title function_">end</span>(<span class="string">`&lt;h1&gt;This is my first server&lt;/h1&gt;`</span>); <span class="comment">// 使用模板字串唷!</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="three-啟動並監聽-listen-伺服器"><a href="#three-啟動並監聽-listen-伺服器" class="headerlink" title=":three: 啟動並監聽(listen)伺服器"></a>:three: <strong>啟動並監聽(listen)伺服器</strong></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">server.<span class="title function_">listen</span>(port, hostname, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`The server is listening on http://<span class="subst">$&#123;hostname&#125;</span>:<span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>成功啟動後，可以在終端機看到 <code>The server is listening on http://localhost:3000</code>，接下來就可以打開瀏覽器輸入 <code>http://localhost:3000</code>，就看到伺服器回應我們的內容 <code>This is my first server</code> !!!</p>
<p>:bulb: <strong>重點說明:</strong></p>
<ul>
<li><p><strong>使用 HTTP 模組方法: server.listen</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">server.<span class="title function_">listen</span>(port, hostname, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 匿名函式</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>:tada::tada::tada:耶!恭喜成功完成你的第一個伺服器，我們帶著這些觀念去挑戰和學習 Express 框架吧!:heartpulse:</p>
<h2 id="mag-right-參考資料來源"><a href="#mag-right-參考資料來源" class="headerlink" title=":mag_right: 參考資料來源"></a>:mag_right: 參考資料來源</h2><p>:pushpin: ALPHA Camp: <a href="https://lighthouse.alphacamp.co/">https://lighthouse.alphacamp.co/</a></p>
<p>:pushpin: Content-type: <a href="https://www.runoob.com/http/http-content-type.html">https://www.runoob.com/http/http-content-type.html</a></p>
<p>:pushpin: HTTP: <a href="https://zapier.com/learn/apis/chapter-2-protocols/">https://zapier.com/learn/apis/chapter-2-protocols/</a></p>
<p>:pushpin: Node.js: <a href="https://nodejs.org/api/http.html">https://nodejs.org/api/http.html</a></p>
]]></content>
      <categories>
        <category>後端</category>
      </categories>
      <tags>
        <tag>expressjs</tag>
        <tag>nodejs</tag>
        <tag>http</tag>
      </tags>
  </entry>
</search>
